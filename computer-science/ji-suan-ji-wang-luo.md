---
description: 先根据小林coding进行总结，后面再逐渐添加面经
---

# 计算机网络

## **1.键入网址到网页显示，期间发生了什么** <a href="#22-jian-ru-wang-zhi-dao-wang-ye-xian-shi-qi-jian-fa-sheng-le-shen-me" id="22-jian-ru-wang-zhi-dao-wang-ye-xian-shi-qi-jian-fa-sheng-le-shen-me"></a>

浏览器做的第一步工作是解析 URL ,URL由协议，域名，目录和文件名组成

> 当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也就是 `/index.html` 或者 `/default.html` 这些文件，这样就不会发生混乱了

对 `URL` 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息

接着需要通过DNS对域名进行解析，得到web服务器的ip地址（本地会有DNS缓存，这也是DNS具有健壮性的重要原因之一）

HTTP 报文是基于 TCP 传输的 , 接着需要通过3次握手建立TCP链接，如果数据超过了MSS的大小还需要进行拆分，最终组成TCP报文段，交由网络层处理

网络层会加上IP头部，随后查表寻找下一跳，如果找到了就直接加上MAC头部，如果没找到就发ARP协议广播寻找，如果找到了会将其缓存到表内

最后通过交换机，路由器送达服务器

数据包抵达服务器后，服务器会查看MAC 头部， IP 头部， TCP 头部，以及序列号

&#x20;HTTP 进程把这个网页封装在 HTTP 响应报文里返回 （ 相同步骤）

浏览器去渲染页面

断开连接



## 2. HTTP是什么

HTTP 超文本传输协议，是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范



## 3.HTTP 常见的状态码有哪些？

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求

* 「**200 OK**」常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
* 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
* 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

* 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
* 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

* 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。(条件GET)

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

* 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
* 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
* 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

* 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
* 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
* 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
* 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。



## 3.GET 和 POST 有什么区别？&#x20;

**GET 的语义是从服务器获取指定的资源**

**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**



## 4. HTTP 缓存有哪些实现方式？

* 强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。 强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
* `Cache-Control`， 是一个相对时间；
* `Expires`，是一个绝对时间；



* **协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**

协商缓存可以基于两种头部来实现。

* 请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
* 请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。



## 5.HTTP/1.1 的优点有哪些？ <a href="#http11-de-you-dian-you-na-xie" id="http11-de-you-dian-you-na-xie"></a>

* _简单_   HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**
* _灵活和易于扩展_    HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**
* _应用广泛和跨平台_&#x20;



## 6. HTTP/1.1 的缺点有哪些？

* _无状态_   因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务  ,但是服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦 （如一些需要确认用户身份的接口），可以使用cookie解决
* _明文传输_  方便阅读，为我们调试工作带了极大的便利性，但信息的内容都毫无隐私可言，很容易就能被窃取
* 不安全 通信使用明文，
  * 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多**
  * 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告**



## 7. HTTP 与 HTTPS 有哪些区别？

* HTTP 是明文传输，存在安全风险的问题。HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
* HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
* 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
* HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



## 8.HTTPS 解决了 HTTP 的哪些问题？

* **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
* **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
* **冒充风险**，比如冒充淘宝网站，用户钱容易没。

如何解决？

* **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
* **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
* 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

## 9. HTTPS 的应用数据是如何保证完整性的？

TLS 在实现上分为**握手协议**和**记录协议**两层：

* TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
* TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；



## 10.HTTPS 一定安全可靠吗？

**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**









