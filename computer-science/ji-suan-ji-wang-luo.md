---
description: 先根据小林coding进行总结，后面再逐渐添加面经
---

# 计算机网络

## **1.键入网址到网页显示，期间发生了什么** <a href="#22-jian-ru-wang-zhi-dao-wang-ye-xian-shi-qi-jian-fa-sheng-le-shen-me" id="22-jian-ru-wang-zhi-dao-wang-ye-xian-shi-qi-jian-fa-sheng-le-shen-me"></a>

浏览器做的第一步工作是解析 URL ,URL由协议，域名，目录和文件名组成

> 当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也就是 `/index.html` 或者 `/default.html` 这些文件，这样就不会发生混乱了

对 `URL` 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息

接着需要通过DNS对域名进行解析，得到web服务器的ip地址（本地会有DNS缓存，这也是DNS具有健壮性的重要原因之一）

HTTP 报文是基于 TCP 传输的 , 接着需要通过3次握手建立TCP链接，如果数据超过了MSS的大小还需要进行拆分，最终组成TCP报文段，交由网络层处理

网络层会加上IP头部，随后查表寻找下一跳，如果找到了就直接加上MAC头部，如果没找到就发ARP协议广播寻找，如果找到了会将其缓存到表内

最后通过交换机，路由器送达服务器

数据包抵达服务器后，服务器会查看MAC 头部， IP 头部， TCP 头部，以及序列号

&#x20;HTTP 进程把这个网页封装在 HTTP 响应报文里返回 （ 相同步骤）

浏览器去渲染页面

断开连接



## 2. HTTP是什么

HTTP 超文本传输协议，是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范



## 3.HTTP 常见的状态码有哪些？

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求

* 「**200 OK**」常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
* 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
* 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

* 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
* 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

* 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。(条件GET)

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

* 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
* 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
* 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

* 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
* 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
* 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
* 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。



## 3.GET 和 POST 有什么区别？&#x20;

**GET 的语义是从服务器获取指定的资源**

**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**



## 4. HTTP 缓存有哪些实现方式？

* 强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。 强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
* `Cache-Control`， 是一个相对时间；
* `Expires`，是一个绝对时间；



* **协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**

协商缓存可以基于两种头部来实现。

* 请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
* 请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。



## 5.HTTP/1.1 的优点有哪些？ <a href="#http11-de-you-dian-you-na-xie" id="http11-de-you-dian-you-na-xie"></a>

* _简单_   HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**
* _灵活和易于扩展_    HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**
* _应用广泛和跨平台_&#x20;



## 6. HTTP/1.1 的缺点有哪些？

* _无状态_   因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务  ,但是服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦 （如一些需要确认用户身份的接口），可以使用cookie解决
* _明文传输_  方便阅读，为我们调试工作带了极大的便利性，但信息的内容都毫无隐私可言，很容易就能被窃取
* 不安全 通信使用明文，
  * 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多**
  * 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告**



## 7. HTTP 与 HTTPS 有哪些区别？

* HTTP 是明文传输，存在安全风险的问题。HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
* HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
* 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
* HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



## 8.HTTPS 解决了 HTTP 的哪些问题？

* **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
* **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
* **冒充风险**，比如冒充淘宝网站，用户钱容易没。

如何解决？

* **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
* **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
* 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

## 9. HTTPS 的应用数据是如何保证完整性的？

TLS 在实现上分为**握手协议**和**记录协议**两层：

* TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
* TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；



## 10.HTTPS 一定安全可靠吗？

**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**



## 11.HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

* 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
* 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

不足 ：

* 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大
* 发送冗长的首部，相互发送相同首部浪费较多
* 队头阻塞
* 没有请求优先级控制
* 请求只能从客户端开始，服务器被动响应



## 12. HTTP/2 做了什么优化？

HTTP/2 相比 HTTP/1.1 性能上的改进：

* 头部压缩（`HPACK` 算法）
* 二进制格式（头信息帧和数据帧） &#x20;
* 并发传输（多个 Stream 复用在一条 TCP 连接）
* 服务器主动推送资源（**双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号）



## 13.HTTP/2 有什么缺陷？

在TCP层仍有队头阻塞问题

> **TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题**



## 14.HTTP/3 做了哪些优化？

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**

UDP 发送是不管顺序，也不管丢包，所以不会出现像 HTTP/2 队头阻塞的问题

&#x20;UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的**可靠性传输**。

QUIC 有以下 3 个特点。

* 无队头阻塞（**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响**）
* 更快的连接建立（QUIC 协议握手过程只需要 1 RTT)
* 连接迁移(通过**连接 ID** 来标记通信的两个端点，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接)



## 15.RPC

* 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
* **RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。
* 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
* RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
* **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

## 16.websocket

* TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
* 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
* 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
* WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
* 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。



## 17.UDP 和 TCP 有什么区别



## 18.TCP 和 UDP 可以使用同一个端口吗？

可以的。

TCP 和 UDP 传输协议，在内核中是两个完全独立的软件模块

因此， TCP/UDP 各自的端口号也相互独立，互不影响。



## 19. 多个 TCP 服务进程可以绑定同一个端口吗？

**如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”**

> 如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。
>
> 这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。



## 20.TCP 三次握手过程是怎样的？

* 客户端发起请求，会随机初始化一个序列号client\_isn ,把SYN标志位标志为一，表示SYN报文，随后发送
* 服务端应答报文也会令SYN = 1，ACK= 1  ，确认应答号=  client\_isn + 1 ，随机初始化自己的序号`server_isn`
* 客户端回复最后一个应答报文，令ACK= 1,确认应答号server\_isn + 1

**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**



## 21.为什么是三次握手？不是两次、四次？

* 三次握手才可以阻止重复历史连接的初始化（主要原因）
* 三次握手才可以同步双方的初始序列号
* 三次握手才可以避免资源浪费



## 22.为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

* 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
* 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；



## 23.既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

由 IP 层进行分片传输，是非常没有效率的









